import * as THREE  from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { CharacterController } from './CharacterController.js';
import { sigmlStringToBML } from './SigmlToBML.js';
import { findIndexOfBone, findIndexOfBoneByName } from './BML.js';
import { BVHLoader, AnimationRetargeting, applyTPose, computeAutoBoneMap } from './Animation.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
// Correct negative blenshapes shader of ThreeJSTHREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n	    objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";class BMLApp {    constructor() {                this.elapsedTime = 0; // clock is ok but might need more time control to dinamicaly change signing speed        this.clock = new THREE.Clock();        this.loaderGLB = new GLTFLoader();                this.controllers = {}; // store avatar controllers        this.ECAcontroller = null; // current selected        this.eyesTarget = null;        this.headTarget = null;        this.neckTarget = null;                this.msg = {};                this.languageDictionaries = {}; // key = NGT, value = { glosses: {}, word2ARPA: {} }        this.selectedLanguage = "NGT";               this.loadedIdleAnimations = {};        this.bindedIdleAnimations = {};        this.currentIdle = "";        this.baseSkeleton = null;        this.applyIdle = false;        this.intensity = 0.3;        this.speed = 1;        this.mood = "Neutral";        this.moodIntensity = 1.0;                this.scene = null;    }    // loads dictionary for mouthing purposes. Not synchronous.    loadMouthingDictionary( language ){        let that = this;                       fetch("./data/dictionaries/" + language + "/IPA/ipa.txt").then(x => x.text()).then(function(text){             let texts = text.split("\n");            let IPADict = {}; // keys: plain text word,   value: ipa transcription            let ARPADict = {}; // keys: plain text word,   value: arpabet transcription                        //https://www.researchgate.net/figure/1-Phonetic-Alphabet-for-IPA-and-ARPAbet-symbols_tbl1_2865098                            let ipaToArpa =  {                // symbols                "'": "", // primary stress                '.': " ", // syllable break                                // vowels                'a': "a",   'ɑ': "a",   'ɒ': "a",                 'œ': "@",   'ɛ': "E",   'ɔ': "c",                'e': "e",   'ø': "e",   'ə': "x",   'o': "o",                  'ɪ': "I",   'i': "i",   'y': "i",   'u': "u",   'ʉ': "u",                // consonants                'x': "k",   'j': "y",   't': "t",   'p': "p",   'l': "l",   'ŋ': "G",                 'k': "k",   'b': "b",   's': "s",   'ʒ': "Z",   'm': "m",   'n': "n",                 'v': "v",   'r': "r",   'ɣ': "g",   'f': "f",   'ʋ': "v",   'z': "z",                 'h': "h",   'd': "d",   'ɡ': "g",   'ʃ': "S",   'ʤ': "J"            };            let errorPhonemes = {};            for(let i = 0; i < texts.length; ++i){                let a = texts[i].replace("\t", "").split("\/");                if (a.length < 2 || a[0].length == 0 || a[1].length == 0 ){ continue; }                IPADict[ a[0] ] = a[1];                let ipa = a[1];                let arpa = "";                // convert each IPA character into correpsonding ARPABet                for( let j = 0; j < ipa.length; ++j ){                    if ( ipa[j] == 'ː' || ipa[j] == ":" ) { arpa += arpa[arpa.length-1]; continue; }                    let s = ipaToArpa[ ipa[j] ];                    if ( s != undefined ){ arpa += s; continue; }                    errorPhonemes[ s ];                }                ARPADict[ a[0] ] = arpa;             }            if ( Object.keys(errorPhonemes).length > 0 ){ console.error( "MOUTHING: loading phonetics: unmapped IPA phonemes to ARPABET: \n", errorPhonemes ); }            that.languageDictionaries[ language ].word2ARPA = ARPADict;        });    }    // convert plain text into phoneme encoding ARPABet-1-letter. Uses dictionaries previously loaded     wordsToArpa ( phrase, language = "NGT" ){                if ( !this.languageDictionaries[ language ] || !this.languageDictionaries[ language ].word2ARPA ){            console.warn( "missing word-ARPABET dictionary for " + language );            return "";        }        let word2ARPA = this.languageDictionaries[ language ].word2ARPA;        let words = phrase.replace(",", "").replace(".", "").split(" ");        let result = "";        let unmappedWords = [];        for ( let i = 0; i < words.length; ++i ){            let r = word2ARPA[ words[i] ] ;            if ( r ){ result += " " + r; }            else{ unmappedWords.push( words[i]); }        }        if ( unmappedWords.length > 0 ){ console.error("MOUTHING: phrase: ", phrase, "\nUnknown words: ",JSON.stringify(unmappedWords)); }        return result;        }    loadLanguageDictionaries( language ){        this.languageDictionaries[ language ] = { glosses: null, wordsToArpa: null };        this.loadMouthingDictionary( language );        fetch( "./data/dictionaries/" + language + "/Glosses/_glossesDictionary.txt").then( (x)=>x.text() ).then( (file) =>{            let glossesDictionary = this.languageDictionaries[ language ].glosses = {};            let lines = file.split("\n");            for( let i = 0; i < lines.length; ++i ){                if ( !lines[i] || lines[i].length < 1 ){ continue; }                let map = lines[i].split("\t");                if ( map.length < 2 ){ continue; }                glossesDictionary[ map[0] ] = map[1].replace("\r", "").replace("\n", "");            }        } );    }    async loadIdleAnimations(animations)    {        let loader = new BVHLoader();        let promises = [];        // Load current character        for(let i = 0; i < animations.length; i++) {            let filePromise = fetch(animations[i]).then(x => x.text()).then((text) =>{                 const data = loader.parseExtended(text);                const name = animations[i].split("/").pop();                                this.loadBVHAnimation( name, data );            })            promises.push(filePromise);        }        return Promise.all(promises);    }    // load animation from bvhe file    loadBVHAnimation(name, animationData) { // TO DO: Refactor params of loadAnimation...()        let skeleton = null;        let bodyAnimation = null;        let faceAnimation = null;        if ( animationData && animationData.skeletonAnim ){            skeleton = animationData.skeletonAnim.skeleton;            if(!skeleton) {                return;            }            skeleton.bones.forEach( b => { b.name = b.name.replace( /[`~!@#$%^&*()|+\-=?;:'"<>\{\}\\\/]/gi, "") } );            // loader does not correctly compute the skeleton boneInverses and matrixWorld             skeleton.bones[0].updateWorldMatrix( false, true ); // assume 0 is root            skeleton = new THREE.Skeleton( skeleton.bones ); // will automatically compute boneInverses                        animationData.skeletonAnim.clip.tracks.forEach( b => { b.name = b.name.replace( /[`~!@#$%^&*()|+\-=?;:'"<>\{\}\\\/]/gi, "") } );                 animationData.skeletonAnim.clip.name = "bodyAnimation";            bodyAnimation = animationData.skeletonAnim.clip;        }                if ( animationData && animationData.blendshapesAnim ){            animationData.blendshapesAnim.clip.name = "faceAnimation";                   faceAnimation = animationData.blendshapesAnim.clip;        }                this.loadedIdleAnimations[name] = {            name: name,            bodyAnimation: bodyAnimation ?? new THREE.AnimationClip( "bodyAnimation", -1, [] ),            faceAnimation: faceAnimation ?? new THREE.AnimationClip( "faceAnimation", -1, [] ),            skeleton,            type: "bvhe"        };    }    /**     * KeyframeEditor: fetches a loaded animation and applies it to the character. The first time an animation is binded, it is processed and saved. Afterwards, this functino just changes between existing animations      * @param {String} animationName      * @param {String} characterName      */    bindAnimationToCharacter(animationName, characterName) {                let animation = this.loadedIdleAnimations[animationName];        if(!animation) {            console.warn(animationName + " not found");            return false;        }        this.currentAnimation = animationName;                let currentCharacter = this.controllers[characterName];        if(!currentCharacter) {            console.warn(characterName + ' not loaded')        }              currentCharacter.originalSkeleton.pose(); // for some reason, mixer.stopAllAction makes bone.position and bone.quaternions undefined. Ensure they have some values        // if not yet binded, create it. Otherwise just change to the existing animation        if ( !this.bindedIdleAnimations[animationName] || !this.bindedIdleAnimations[animationName][currentCharacter.character.name] ) {            let bonesNames = [];            let bodyAnimation = animation.bodyAnimation;                    if(bodyAnimation) {                            let tracks = [];                        // Remove position changes (only keep i == 0, hips)                for (let i = 0; i < bodyAnimation.tracks.length; i++) {                    if(bodyAnimation.tracks[i].name.includes('position')) {                        continue;                    }                    tracks.push(bodyAnimation.tracks[i]);                    tracks[tracks.length - 1].name = tracks[tracks.length - 1].name.replace( /[\[\]`~!@#$%^&*()|+\-=?;:'"<>\{\}\\\/]/gi, "").replace(".bones", "");                }                bodyAnimation.tracks = tracks;                            let skeleton = animation.skeleton;                            let retargeting = new AnimationRetargeting(skeleton, currentCharacter.character, { trgUseCurrentPose: true, trgEmbedWorldTransforms: true, srcPoseMode: AnimationRetargeting.BindPoseModes.TPOSE, trgPoseMode: AnimationRetargeting.BindPoseModes.TPOSE } ); // TO DO: change trgUseCurrentPose param                bodyAnimation = retargeting.retargetAnimation(bodyAnimation);                                bonesNames = this.validateAnimationClip(bodyAnimation);                bodyAnimation.name = "bodyAnimation";   // mixer            }                            let faceAnimation = animation.faceAnimation;                               if(!this.bindedIdleAnimations[animationName]) {                this.bindedIdleAnimations[animationName] = {};            }            this.bindedIdleAnimations[animationName][currentCharacter.character.name] = {                mixerBodyAnimation: bodyAnimation, mixerFaceAnimation: faceAnimation, bonesNames // for threejs mixer             }        }        let bindedAnim = this.bindedIdleAnimations[animationName][currentCharacter.character.name];                // Remove current animation clip        let mixer = currentCharacter.mixer;        mixer.stopAllAction();                while(mixer._actions.length){            mixer.uncacheClip(mixer._actions[0]._clip); // removes action        }        mixer.clipAction(bindedAnim.mixerBodyAnimation).setEffectiveWeight(this.intensity).play();        mixer.update(0);        this.mixer = mixer;        this.duration = bindedAnim.mixerBodyAnimation.duration;               // Clone skeleton with first frame of animation applied, for using it in additive blending        let bones = currentCharacter.originalSkeleton.bones;        let resultBones = new Array( bones.length );                // bones[0].clone( true ); // recursive        for( let i = 0; i < bones.length; ++i ){            resultBones[i] = bones[i].clone(false);            resultBones[i].parent = null;        }                for( let i = 0; i < bones.length; ++i ){            let parentIdx = findIndexOfBone(currentCharacter.originalSkeleton, bones[i].parent);            if ( parentIdx > -1 ){ resultBones[ parentIdx ].add( resultBones[ i ] ); }           }                resultBones[0].updateWorldMatrix( false, true ); // assume 0 is root. Update all global matrices (root does not have any parent)                  this.baseSkeleton = new THREE.Skeleton(resultBones);               return true;    }    /** Validate body animation clip created using ML */    validateAnimationClip(clip) {        let newTracks = [];        let tracks = clip.tracks;        let bones = this.ECAcontroller.originalSkeleton.bones;        let bonesNames = [];        tracks.map((v) => { bonesNames.push(v.name.split(".")[0])});        for(let i = 0; i < bones.length; i++)        {                        let name = bones[i].name;            if(bonesNames.indexOf( name ) > -1)                continue;            let times = [0];            let values = [bones[i].quaternion.x, bones[i].quaternion.y, bones[i].quaternion.z, bones[i].quaternion.w];                        let track = new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, values);            newTracks.push(track);                    }        clip.tracks = clip.tracks.concat(newTracks);        return bonesNames;    }    init(scene) {        this.loadLanguageDictionaries( "NGT" );                // Behaviour Planner        this.eyesTarget = new THREE.Object3D(); //THREE.Mesh( new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: 0xffff00 , depthWrite: false }) );        this.eyesTarget.name = "eyesTarget";        this.eyesTarget.position.set(0, 2.5, 15);         this.headTarget = new THREE.Object3D(); //THREE.Mesh( new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: 0xff0000 , depthWrite: false }) );        this.headTarget.name = "headTarget";        this.headTarget.position.set(0, 2.5, 15);         this.neckTarget = new THREE.Object3D(); //THREE.Mesh( new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: 0x00fff0 , depthWrite: false }) );        this.neckTarget.name = "neckTarget";        this.neckTarget.position.set(0, 2.5, 15);         scene.add(this.eyesTarget);        scene.add(this.headTarget);        scene.add(this.neckTarget);        this.scene = scene;    }            update( deltaTime ) {        deltaTime*=this.speed;        this.elapsedTime += deltaTime;                if ( this.ECAcontroller ){ this.ECAcontroller.update( deltaTime, this.elapsedTime ); }                const bmlSkeleton = this.ECAcontroller.skeleton;        const animatedSkeleton = this.ECAcontroller.originalSkeleton;        // Apply additive blending animation to the bml animation        if(this.applyIdle && this.baseSkeleton && this.mixer) {            if(this.mixer) {                this.mixer.update(deltaTime/this.speed);                       }            const anim = this.bindedIdleAnimations[this.currentIdle][this.ECAcontroller.character.name];            const boneNames = anim.bonesNames;                        for(let i = 0; i < bmlSkeleton.bones.length; i++) {                                let input = bmlSkeleton.bones[i].quaternion.clone();                                if(bmlSkeleton.bones[i].name.includes("RightHand") || bmlSkeleton.bones[i].name.includes("LeftHand") || boneNames.indexOf(bmlSkeleton.bones[i].name) < 0) {                    animatedSkeleton.bones[i].quaternion.copy(input);                    animatedSkeleton.bones[i].position.copy(bmlSkeleton.bones[i].position);                                        continue;                }                const add = animatedSkeleton.bones[i].quaternion.clone();                const addBase = this.baseSkeleton.bones[i].quaternion.clone();                input.multiply(addBase.invert().multiply(add));                animatedSkeleton.bones[i].quaternion.copy(input);            }            animatedSkeleton.bones[0].updateWorldMatrix(false, true);                } else {            for(let i = 0; i < bmlSkeleton.bones.length; i++) {                 animatedSkeleton.bones[i].position.copy(bmlSkeleton.bones[i].position);                animatedSkeleton.bones[i].quaternion.copy(bmlSkeleton.bones[i].quaternion);                animatedSkeleton.bones[i].scale.copy(bmlSkeleton.bones[i].scale);            }        }    }    replay() {        if(!this.msg) {            return;        }                this.ECAcontroller.processMsg( JSON.parse( JSON.stringify(this.msg) ) );     }    onLoadAvatar(newAvatar, config, skeleton){        newAvatar.eyesTarget = this.eyesTarget;        newAvatar.headTarget = this.headTarget;        newAvatar.neckTarget = this.neckTarget;                    const mixer = new THREE.AnimationMixer(newAvatar);          this.mixer = mixer;        // Clone skeleton in bind pose for the CharacterController (compute the animation in an auxiliary skeleton)        skeleton.pose();        let bones = skeleton.bones;        let resultBones = new Array( bones.length );                // bones[0].clone( true ); // recursive        for( let i = 0; i < bones.length; ++i ){            resultBones[i] = bones[i].clone(false);            resultBones[i].parent = null;        }                for( let i = 0; i < bones.length; ++i ){            let parentIdx = findIndexOfBone( skeleton, bones[i].parent )            if ( parentIdx > -1 ){ resultBones[ parentIdx ].add( resultBones[ i ] ); }           }        let root = bones[0].parent.clone(false);        root.add(resultBones[0]);        if(bones[0].parent.parent) {            let parent = bones[0].parent.parent.clone(false);            parent.add(root);            this.scene.add(parent)        }        else {            this.scene.add(root)        }        resultBones[0].updateWorldMatrix( true, true ); // assume 0 is root. Update all global matrices (root does not have any parent)        let resultSkeleton = new THREE.Skeleton(resultBones);        let ECAcontroller = new CharacterController( {character: newAvatar, characterConfig: config, skeleton: resultSkeleton} );        ECAcontroller.start();        ECAcontroller.reset();        ECAcontroller.processMsg( { control: 2 } ); // speaking mode        ECAcontroller.originalSkeleton = skeleton;        ECAcontroller.mixer = mixer;        this.ECAcontroller = this.controllers[newAvatar.name] = ECAcontroller;        if(!Object.keys(this.loadedIdleAnimations).length) {            this.loadIdleAnimations(["./data/animations/Idle.bvh", "./data/animations/SitIdle.bvh", "./data/animations/standingIdle.bvh"]).then((v) => {                if(!Object.keys(this.loadedIdleAnimations).length) {return;}                this.currentIdle = Object.keys(this.loadedIdleAnimations)[0].replace("./data/animations/", "");                this.bindAnimationToCharacter(this.currentIdle, newAvatar.name);            })        }        else {            this.bindAnimationToCharacter(this.currentIdle, newAvatar.name);        }    }    onChangeAvatar(avatarName) {        if (!this.controllers[avatarName]) {             return false;         }        this.ECAcontroller = this.controllers[avatarName];        return true;    }    getLookAtPosition(target = new THREE.Vector3()) {        if( this.ECAcontroller ) {             this.ECAcontroller.skeleton.bones[ this.ECAcontroller.characterConfig.boneMap["ShouldersUnion"] ].getWorldPosition( target );         }        return target;    }    /*     * Given an array of blocks of type { type: "bml" || "sigml" || "glossName",  data: "" } where data contains the text instructions either in bml or sigml.    * It computes the sequential union of all blocks.    * Provides a way to feed the app with custom bmls, sigml     * Returns duration of the whole array, without delayTime    */    async processMessageRawBlocks( glosses = [], delayTime = 0 ){        if ( !glosses ){ return null; }        delayTime = parseFloat( delayTime );        delayTime = isNaN( delayTime ) ? 0 : delayTime;        let time = delayTime;        let orders = []; // resulting bml instructions        let glossesDictionary = this.languageDictionaries[ this.selectedLanguage ].glosses;                let peakRelaxDuration = 0;        let relaxEndDuration = 0;                for( let i = 0; i < glosses.length; ++i ){            let gloss = glosses[i];                        try{                 // if gloss name. First fetch file, update gloss data and continue                if ( gloss.type == "glossName" ){                    let glossFile = glossesDictionary[ gloss.data ];                    if ( !glossFile ){  // skipping gloss                        gloss = { type: "invalid" };                    }                    else{                         await fetch( "./data/dictionaries/" + this.selectedLanguage + "/Glosses/" + glossFile ).then(x=>x.text()).then( (text) =>{                             let extension = glossFile.split(".");                            extension = extension[ extension.length - 1 ];                            gloss = { type: extension, data: text };                        } );                        }                }                if ( gloss.type == "bml" ){ // BML                    let result = gloss.data;                    if( typeof( result ) == "string" ){ result = JSON.parse( result ) };                    if ( Array.isArray( result.behaviours ) ){ result = result.behaviours; } // animics returns this                    else if ( Array.isArray( result.data ) ){ result = result.data; } // bml messages uses this                    else if ( !Array.isArray( result ) ){ throw "error"; }                    time = time - relaxEndDuration - peakRelaxDuration; // if not last, remove relax-end and peak-relax stages                    let maxDuration = 0;                    let maxRelax = 0;                    for( let b = 0; b < result.length; ++b ){                        let bml = result[b];                        if( !isNaN( bml.start ) ){ bml.start += time; }                        if( !isNaN( bml.ready ) ){ bml.ready += time; }                        if( !isNaN( bml.attackPeak ) ){ bml.attackPeak += time; }                        if( !isNaN( bml.relax ) ){                             if ( maxRelax < bml.relax ){ maxRelax = bml.relax; }                             bml.relax += time;                          }                        if( !isNaN( bml.end ) ){                             if ( maxDuration < bml.end ){ maxDuration = bml.end; }                             bml.end += time;                         }                    }                    orders = orders.concat( result );                    time += maxDuration; // time up to last end                    peakRelaxDuration = 0;                    relaxEndDuration = maxDuration - maxRelax;                }                else if ( gloss.type == "sigml" ){ // SiGML                    time = time - relaxEndDuration - peakRelaxDuration; // if not last, remove relax-end and peak-relax stages                    let result = sigmlStringToBML( gloss.data, time );                    orders = orders.concat(result.data);                    time += result.duration;                     peakRelaxDuration = result.peakRelaxDuration;                    relaxEndDuration = result.relaxEndDuration;                }                else{                    // TODO DEFAULT SKIPPING SIGN MESSAGE                    time += 3; continue;                 }            }catch(e){ console.log( "parse error: " + gloss ); time += 3; }        }        // give the orders to the avatar controller         let msg = {            type: "behaviours",            data: orders        };        this.msg = JSON.parse(JSON.stringify(msg)); // make copy        this.ECAcontroller.processMsg( msg );        return { msg: msg, duration: time - delayTime, peakRelaxDuration: peakRelaxDuration, relaxEndDuration: relaxEndDuration }; // duration    }    onMessage(data, callback){        if ( !data || !Array.isArray(data) ) {            return;        }        this.ECAcontroller.reset();        this.processMessageRawBlocks( data ).then((processedData)=>{             if(callback) {                callback(processedData);            }                  } );              };    setIntensity(value) {        this.intensity = value;        if(this.mixer && this.mixer._actions.length) {            this.mixer._actions[0].setEffectiveWeight(value);            this.mixer.update(0);            let bones = this.ECAcontroller.originalSkeleton.bones;                for( let i = 0; i < bones.length; ++i ){            this.baseSkeleton.bones[i].position.copy(bones[i].position);            this.baseSkeleton.bones[i].quaternion.copy(bones[i].quaternion);            this.baseSkeleton.bones[i].scale.copy(bones[i].scale);        }                this.baseSkeleton.bones[0].updateWorldMatrix( false, true ); // assume 0 is root. Update all global matrices (root does not have any parent)                  this.baseSkeleton.calculateInverses();        }    }}
class KeyframeApp {    constructor() {                this.elapsedTime = 0; // clock is ok but might need more time control to dinamicaly change signing speed        this.clock = new THREE.Clock();        this.GLTFLoader = new GLTFLoader();        this.BVHLoader = new BVHLoader();                this.currentCharacter = "";        this.loadedCharacters = {}; // store avatar loadedCharacters        this.currentAnimation = "";        this.loadedAnimations = {};        this.bindedAnimations = {};        this.mixer = null;        this.playing = false;        this.speed = 1;        // For retargeting        this.srcPoseMode = AnimationRetargeting.BindPoseModes.DEFAULT;         this.trgPoseMode = AnimationRetargeting.BindPoseModes.DEFAULT;            this.srcEmbedWorldTransforms = false;        this.trgEmbedWorldTransforms = true;    }    update( deltaTime ) {        deltaTime*= this.speed;        this.elapsedTime += deltaTime;        if (this.playing && this.mixer) {             this.mixer.update( deltaTime );         }    }    changePlayState(state = !this.playing) {        this.playing = state;        if(this.playing && this.mixer) {            this.mixer.setTime(0);                              }    }    onLoadAvatar(character){              // Create mixer for animation        const mixer = new THREE.AnimationMixer(character.model);          this.currentCharacter = character.model.name;        this.loadedCharacters[character.model.name] = character;        this.loadedCharacters[character.model.name].mixer = mixer;        this.mixer = mixer;    }    onChangeAvatar(avatarName) {        if (!this.loadedCharacters[avatarName]) {             return false;         }        this.currentCharacter = avatarName;        this.changePlayState(this.playing);        this.mixer = this.loadedCharacters[avatarName].mixer;          this.bindAnimationToCharacter(this.currentAnimation, avatarName);        const LToePos = this.loadedCharacters[avatarName].skeleton.getBoneByName(this.loadedCharacters[avatarName].LToeName).getWorldPosition(new THREE.Vector3);        const RToePos = this.loadedCharacters[avatarName].skeleton.getBoneByName(this.loadedCharacters[avatarName].RToeName).getWorldPosition(new THREE.Vector3);        let diff = this.loadedCharacters[avatarName].LToePos.y - LToePos.y;                 this.loadedCharacters[avatarName].model.position.y = this.loadedCharacters[avatarName].position.y - this.loadedCharacters[avatarName].diffToGround + diff;        return true;    }    onChangeAnimation(animationName) {        if(!this.loadedAnimations[animationName]) {            console.warn(animationName + 'not found')        }        this.currentAnimation = animationName;        this.loadedCharacters[this.currentCharacter].model.position.y = this.loadedCharacters[this.currentCharacter].position.y;        this.bindAnimationToCharacter(this.currentAnimation, this.currentCharacter);        const LToePos = this.loadedCharacters[this.currentCharacter].model.getObjectByName(this.loadedCharacters[this.currentCharacter].LToeName).getWorldPosition(new THREE.Vector3);        const RToePos = this.loadedCharacters[this.currentCharacter].model.getObjectByName(this.loadedCharacters[this.currentCharacter].RToeName).getWorldPosition(new THREE.Vector3);        let diff = this.loadedCharacters[this.currentCharacter].LToePos.y - LToePos.y;                 this.loadedCharacters[this.currentCharacter].model.position.y = this.loadedCharacters[this.currentCharacter].position.y - this.loadedCharacters[this.currentCharacter].diffToGround + diff;    }    onMessage( data, callback ) {        this.processMessageFiles(data.data).then( (processedAnimationNames) => {            if( processedAnimationNames && processedAnimationNames.length && this.loadedAnimations[processedAnimationNames[0]] ) {                this.currentAnimation = processedAnimationNames[0];                this.bindAnimationToCharacter(this.currentAnimation, this.currentCharacter);            }            if(callback) {                callback(processedAnimationNames);            }            //this.gui.animationDialog.refresh();        });    }    /*     * Given an array of animations of type { name: "", data: "" } where "data" is Blob of text/plain type     *     */     async processMessageFiles( files = []) {        let parsedFiles = {};        let promises = [];        let loader = null;        let type = 'bvh';        for(let i = 0; i < files.length; i++) {            const file = files[i];            const extension = file.name.substr(file.name.lastIndexOf(".") + 1);;            if(extension == 'bvh' || extension == 'bvhe') {                loader = this.BVHLoader;                type = 'bvh';            }            else {                loader = this.GLTFLoader;                type = 'glb';            }            let filePromise = null;            if(type == 'bvh') {                filePromise = new Promise(resolve => {                    const reader = new FileReader();                    reader.onload = () => {                                 let data = null;                            data = this.BVHLoader.parseExtended(reader.result);                            this.loadBVHAnimation( file.name, data );                        resolve( file.name ); // this is what is returned by promise.all.then                    }                    let data = file.data ?? file;                    reader.readAsText(data);                });            }            else {                filePromise = new Promise(resolve => {                    const reader = new FileReader();                    reader.onload = () => {                          this.GLTFLoader.load( reader.result, (glb) => {                            let skeleton = null;                            glb.scene.traverse( o => {                                                                    if ( o.skeleton ){                                     skeleton = o.skeleton;                                    return;                                }                                                                            } );                            let animationsNames = [];                            if ( skeleton ){                                let model = skeleton.bones[0];                                while(model.parent && model.parent.type != "Scene") {                                    model = model.parent;                                }                                model.skeleton = skeleton;                            }else if ( this.loadedAnimations[this.currentAnimation] ){                                skeleton = this.loadedAnimations[this.currentAnimation].skeleton;                            }else{                                resolve( animationsNames ); // this is what is returned by promise.all.then                                return;                            }                            for(let i = 0; i < glb.animations.length; i++) {                                this.loadGLTFAnimation(glb.animations[i].name, glb.animations[i], skeleton);                                animationsNames.push(glb.animations[i].name);                            }                            resolve( animationsNames ); // this is what is returned by promise.all.then                        });                     }                                        let data = file.data ?? file;                    reader.readAsDataURL(data);                });            }               promises.push(filePromise);                   }               return Promise.all(promises);    }    // load animation from bvhe file    loadBVHAnimation(name, animationData) { // TO DO: Refactor params of loadAnimation...()        let skeleton = null;        let bodyAnimation = null;        let faceAnimation = null;        if ( animationData && animationData.skeletonAnim ){            skeleton = animationData.skeletonAnim.skeleton;            if(!skeleton) {                return;            }            skeleton.bones.forEach( b => { b.name = b.name.replace( /[`~!@#$%^&*()_|+\-=?;:'"<>\{\}\\\/]/gi, "") } );            // loader does not correctly compute the skeleton boneInverses and matrixWorld             skeleton.bones[0].updateWorldMatrix( false, true ); // assume 0 is root            skeleton = new THREE.Skeleton( skeleton.bones ); // will automatically compute boneInverses                        animationData.skeletonAnim.clip.tracks.forEach( b => { b.name = b.name.replace( /[`~!@#$%^&*()_|+\-=?;:'"<>\{\}\\\/]/gi, "") } );                 animationData.skeletonAnim.clip.name = "bodyAnimation";            bodyAnimation = animationData.skeletonAnim.clip;        }                if ( animationData && animationData.blendshapesAnim ){            animationData.blendshapesAnim.clip.name = "faceAnimation";                   faceAnimation = animationData.blendshapesAnim.clip;        }                this.loadedAnimations[name] = {            name: name,            bodyAnimation: bodyAnimation ?? new THREE.AnimationClip( "bodyAnimation", -1, [] ),            faceAnimation: faceAnimation ?? new THREE.AnimationClip( "faceAnimation", -1, [] ),            skeleton,            type: "bvhe"        };    }    loadGLTFAnimation(name, animationData, skeleton) {        this.loadedAnimations[name] = {            name: name,            bodyAnimation: animationData ?? new THREE.AnimationClip( "bodyAnimation", -1, [] ),            skeleton,            type: "glb"        };    }    /**     * KeyframeEditor: fetches a loaded animation and applies it to the character. The first time an animation is binded, it is processed and saved. Afterwards, this functino just changes between existing animations      * @param {String} animationName      * @param {String} characterName      */    bindAnimationToCharacter(animationName, characterName) {                let animation = this.loadedAnimations[animationName];        if(!animation) {            console.warn(animationName + " not found");            return false;        }        this.currentAnimation = animationName;                let currentCharacter = this.loadedCharacters[characterName];        if(!currentCharacter) {            console.warn(characterName + ' not loaded')        }        // Remove current animation clip        let mixer = currentCharacter.mixer;        mixer.stopAllAction();        while(mixer._actions.length){            mixer.uncacheClip(mixer._actions[0]._clip); // removes action        }        let srcPoseMode = this.srcPoseMode;        let trgPoseMode = this.trgPoseMode;        if(this.trgPoseMode != AnimationRetargeting.BindPoseModes.CURRENT && this.trgPoseMode != AnimationRetargeting.BindPoseModes.DEFAULT) {            const skeleton = applyTPose(currentCharacter.skeleton).skeleton;            if(skeleton)            {                currentCharacter.skeleton = skeleton;                trgPoseMode = AnimationRetargeting.BindPoseModes.CURRENT;            }            else {                console.warn("T-pose can't be applyied to the TARGET. Automap falied.")            }        }         else {            currentCharacter.skeleton.pose(); // for some reason, mixer.stopAllAction makes bone.position and bone.quaternions undefined. Ensure they have some values        }                // if not yet binded, create it. Otherwise just change to the existing animation        if ( !this.bindedAnimations[animationName] || !this.bindedAnimations[animationName][currentCharacter.name] ) {            let bodyAnimation = animation.bodyAnimation;                    if(bodyAnimation) {                            let tracks = [];                        // Remove position changes (only keep i == 0, hips)                for (let i = 0; i < bodyAnimation.tracks.length; i++) {                    if(i && bodyAnimation.tracks[i].name.includes('position')) {                        continue;                    }                    tracks.push(bodyAnimation.tracks[i]);                    tracks[tracks.length - 1].name = tracks[tracks.length - 1].name.replace( /[\[\]`~!@#$%^&*()_|+\-=?;:'"<>\{\}\\\/]/gi, "").replace(".bones", "");                }                //tracks.forEach( b => { b.name = b.name.replace( /[`~!@#$%^&*()_|+\-=?;:'"<>\{\}\\\/]/gi, "") } );                bodyAnimation.tracks = tracks;                                            if(this.srcPoseMode != AnimationRetargeting.BindPoseModes.CURRENT && this.srcPoseMode != AnimationRetargeting.BindPoseModes.DEFAULT) {                    const skeleton = applyTPose(animation.skeleton).skeleton;                    if(skeleton)                    {                        animation.skeleton = skeleton;                        srcPoseMode = AnimationRetargeting.BindPoseModes.CURRENT;                    }                    else {                        console.warn("T-pose can't be applyied to the SOURCE. Automap falied.")                    }                }                                             let retargeting = new AnimationRetargeting(animation.skeleton, currentCharacter.model, { srcEmbedWorldTransforms: this.srcEmbedWorldTransforms, trgEmbedWorldTransforms: this.trgEmbedWorldTransforms, srcPoseMode, trgPoseMode } ); // TO DO: change trgUseCurrentPose param                bodyAnimation = retargeting.retargetAnimation(bodyAnimation);                                this.validateAnimationClip(bodyAnimation);                bodyAnimation.name = "bodyAnimation";   // mixer            }                            let faceAnimation = animation.faceAnimation;                    if(!this.bindedAnimations[animationName]) {                this.bindedAnimations[animationName] = {};            }            this.bindedAnimations[animationName][this.currentCharacter] = {                mixerBodyAnimation: bodyAnimation, mixerFaceAnimation: faceAnimation, // for threejs mixer             }        }        let bindedAnim = this.bindedAnimations[animationName][this.currentCharacter];        mixer.clipAction(bindedAnim.mixerBodyAnimation).setEffectiveWeight(1.0).play();        mixer.update(0);        this.duration = bindedAnim.mixerBodyAnimation.duration;        this.mixer = mixer;        return true;    }    /** Validate body animation clip created using ML */    validateAnimationClip(clip) {        let newTracks = [];        let tracks = clip.tracks;        let bones = this.loadedCharacters[this.currentCharacter].skeleton.bones;        let bonesNames = [];        tracks.map((v) => { bonesNames.push(v.name.split(".")[0])});        for(let i = 0; i < bones.length; i++)        {                        let name = bones[i].name;            if(bonesNames.indexOf( name ) > -1)                continue;            let times = [0];            let values = [bones[i].quaternion.x, bones[i].quaternion.y, bones[i].quaternion.z, bones[i].quaternion.w];                        let track = new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, values);            newTracks.push(track);                    }        clip.tracks = clip.tracks.concat(newTracks);    }    }
let zip = typeof JSZip != 'undefined' ? new JSZip() : null;class AnimationRecorder {    constructor(numCameras, app) {        this.isRecording = false;        this.timeLimit = null;        this.mediaRecorders = [];        this.recordedChunks = [];        this.renderers = [];        this.clock = new THREE.Clock();        this.handleDataAvailable = this.handleDataAvailable.bind(this);        this.handleStop = this.handleStop.bind(this);        this.animationsCount = 0;        this.enabledCameras = 0;        for (let i = 0; i < numCameras; i++) {            // offscreen renderer for each camera            const offscreenRenderer = new THREE.WebGLRenderer( {antialias: true} );            offscreenRenderer.setSize(window.innerWidth, window.innerHeight);            offscreenRenderer.setPixelRatio(window.devicePixelRatio);            offscreenRenderer.toneMapping = THREE.LinearToneMapping;            offscreenRenderer.toneMappingExposure = 1;            this.renderers.push(offscreenRenderer);            const stream = this.renderers[i].domElement.captureStream(60);            const options = { mimeType: 'video/webm;', videoBitsPerSecond: 5 * 1024 * 1024 }; // 5 Mbps            const mediaRecorder = new MediaRecorder(stream, options);            mediaRecorder.ondataavailable = (event) => this.handleDataAvailable(event, i);            mediaRecorder.onstop = () => this.handleStop(i);            mediaRecorder.onstart = () => this.handleStart(i);            this.mediaRecorders.push( mediaRecorder );            this.recordedChunks.push([]);        };        this.app = app;    }    async manageMultipleCapture (keyframeApp) {        this.keyframeApp = keyframeApp;        let animations = [];                for (let animationName in keyframeApp.loadedAnimations) {            let animation = keyframeApp.loadedAnimations[animationName];            if (!animation.record) {                continue;            }            animations.push(animationName);        }        this.animationsCount = animations.length;        for (let i = 0; i < animations.length; i++) {            const animationName = animations[i];            let animation = keyframeApp.loadedAnimations[animationName];            if(this.onStartCapture) {                this.onStartCapture('(' + (i+1) + '/' + animations.length+ ') ' + animationName);            }            await this.manageCapture(animationName, animation.bodyAnimation.duration);        }    }    manageCapture (animationName, timeLimit = null) {        if (this.app.mode == App.Modes.SCRIPT){            this.animationsCount = 1;            if(this.onStartCapture) {                this.onStartCapture('');            }            if (this.isRecording) {                 this.stopCapture();                 // if(this.onStopCapture) {                //     this.onStopCapture();                // }            }            else { this.startCapture("BML"); }        }        else if (this.app.mode == App.Modes.KEYFRAME) {                    return new Promise((resolve) => {                this.onCaptureComplete = resolve;                this.keyframeApp.onChangeAnimation(animationName);                this.startCapture(animationName);                                // automatically stop recording after animation stops                this.timeLimit = timeLimit; // in seconds            });        }    }    startCapture (animationName,) {        this.isRecording = true;        this.enabledCameras = 0;        for( let i = 0; i < this.app.cameras.length; i++) {            if(!this.app.cameras[i].record) {                continue;            }            this.enabledCameras += 1;            this.recordedChunks[i] = [];            this.mediaRecorders[i].start();        }        // this.recordedChunks.forEach((chunk, i, arr) => arr[i] = []); // reset chuncks        // this.mediaRecorders.forEach(recorder => { recorder.start() });        this.currentAnimationName = animationName; // Store the animation name    }            stopCapture () {        this.isRecording = false;        this.mediaRecorders.forEach(recorder => recorder.stop());       }    handleDataAvailable (event, idx) {        if (event.data.size > 0) {            this.recordedChunks[idx].push(event.data);        }    }    handleStart (idx) {        if (idx === 0) {            if (this.app.mode == App.Modes.SCRIPT){                this.app.bmlApp.replay();            }            else if (this.app.mode == App.Modes.KEYFRAME) {                this.app.keyframeApp.changePlayState(true); // start animation                if(this.app.gui) {                    this.app.gui.keyframeGui.refresh();                }            }        }        this.clock.start();    }    handleStop (idx) {        const animationName = this.currentAnimationName;        const blob = new Blob(this.recordedChunks[idx], {type: 'video/webm'});        const name =  `${animationName} ${idx + 1}.webm`;        blobToBase64(blob, (binaryData) => {            if(!zip) {                console.error("JSZip not imported. The recordings can't be downloaded.");                return;            }            // Add downloaded file video to zip in the specified folder:            zip.folder(animationName).file(name, binaryData, {base64: true})            let files = Object.keys(zip.files);            if((files.length - this.animationsCount) == this.animationsCount * this.enabledCameras) {                if(this.onStopCapture) {                    this.onStopCapture();                }                // All files have been downloaded, create the zip and download it                zip.generateAsync({type:"base64"}).then(function (base64) {                    let zipName = 'performs-recordings.zip';                    let a = document.createElement('a');                     // Then trigger the download link                    a.href = "data:application/zip;base64," + base64;                    a.download = zipName;                    a.click();                    zip.files = {};                });            }        });        // refresh gui        if (idx === 0) {            if (this.app.mode == App.Modes.KEYFRAME) {                this.app.gui.keyframeGui.refresh();            }            else if (this.app.mode == App.Modes.SCRIPT) {                // reset avatar pose / stop animation                this.app.bmlApp.ECAcontroller.reset(true);            }        }        // reset clock to 0        this.clock.elapsedTime = 0;        this.clock.stop();        // Check if all recorders have stopped        if (this.mediaRecorders.every(recorder => recorder.state === 'inactive')) {            if (this.onCaptureComplete) {                this.onCaptureComplete(); // Resolve the promise to indicate that capture is complete                this.onCaptureComplete = null; // Clear the reference            }        }    }    update (scene, cameras) {        // render for all cameras        for (let i = 0; i < this.renderers.length; i++) {            this.renderers[i].render( scene, cameras[i] );        }        if (this.timeLimit && this.clock.getElapsedTime() > this.timeLimit ) {            this.app.keyframeApp.changePlayState(false);  // stop animation            this.stopCapture();        }    }}function blobToBase64(blob, callback) {    var reader = new FileReader();    reader.onload = function() {        var dataUrl = reader.result;        var base64 = dataUrl.split(',')[1];        callback(base64);    };    reader.readAsDataURL(blob);}
// Correct negative blenshapes shader of ThreeJSTHREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n	    objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";class App {    static Modes = { SCRIPT: 0, KEYFRAME: 1 };    static Backgrounds = { OPEN:0, STUDIO: 1, PHOTOCALL: 2};    static ATELIER_URL = "https://webglstudio.org/projects/signon/performs-atelier/";    constructor() {                this.elapsedTime = 0; // clock is ok but might need more time control to dinamicaly change signing speed        this.clock = new THREE.Clock();        this.loaderGLB = new GLTFLoader();                this.scene = null;        this.renderer = null;        this.camera = null;        this.cameras = [];        this.controls = [];        this.cameraMode = 0;        this.loadedCharacters = {};        this.currentCharacter = null;        this.speed = 1;        this.backPlane = null;        this.avatarShirt = null;        this.mode = App.Modes.SCRIPT;        this.bmlApp = new BMLApp();                this.keyframeApp = new KeyframeApp();                   this.isAppReady = false;        this.pendingMessageReceived = null;        this.sceneColor = 0x46c219;        this.background = App.Backgrounds.OPEN;        this.logo = "./data/imgs/performs2.png";        this._atelier = null;        this.raycaster = new THREE.Raycaster();    }    setSpeed( value ){ this.speed = value; }    getSpeed( ){ return this.speed; }    changeMode( mode ) {        this.mode = mode;        if(this.currentCharacter) {            this.currentCharacter.skeleton.pose();        }        if(this.bmlApp.ECAcontroller) {            this.bmlApp.ECAcontroller.reset();            this.bmlApp.ECAcontroller.update(0,0);        }        if(this.gui) {            this.gui.onChangeMode(mode);        }    }    // returns value (hex) with the colour in sRGB space    getBackPlaneColour(){        if ( !this.backPlane ){ return 0; }          let color = null;         if(this.backPlane.material.color) {            color = this.backPlane.material.color.getHex();           }        else {            color = this.backPlane.material.uniforms.color.value.getHex();        }        return color; // css works in sRGB    }    // value (hex colour) in sRGB space     setBackPlaneColour( value ){        this.sceneColor = value;        this.scene.background.set(value);        if ( this.backPlane ){             if(this.backPlane.material.color) {                this.backPlane.material.color.set( value );               }            else {                this.photocallMaterial.uniforms.color.value.set(value);                this.backPlane.material.uniforms.color.value.set(value);                this.backPlane.material.needsUpdate = true;            }        }                        if(this.ground) {            this.ground.material.color.set( value );         }        return true;    }        setBackground( type, image = null ) {        this.background = type;        switch(type) {            case App.Backgrounds.OPEN:                this.backPlane.visible = false;                this.ground.visible = true;                break;            case App.Backgrounds.STUDIO:                this.backPlane.visible = true;                // this.backPlane.material.map = null;                        this.backPlane.material = this.studioMaterial;                                    this.backPlane.material.color.set(this.sceneColor);                this.backPlane.material.needsUpdate = true;                this.ground.visible = false;                               break;            case App.Backgrounds.PHOTOCALL:                this.backPlane.visible = true;                this.ground.visible = false;                // let texture = null;                if(image) {                    if(typeof(image) == 'string') {                        this.logoTexture = new THREE.TextureLoader().load( this.logo);                        }                    else {                        this.logoTexture = new THREE.Texture( this.logo );                        this.logoTexture.colorSpace = THREE.SRGBColorSpace;                    }                                               this.logoTexture.needsUpdate = true;                    const shader = this.backPlane.material.userData.shader;                    if ( shader ) {                        shader.uniforms.textureMap.value = this.logoTexture;                    }                    else {                        this.photocallMaterial.uniforms.textureMap.value = this.logoTexture;                          }                }                this.backPlane.material = this.photocallMaterial;                if(this.backPlane.material.color) {                    this.backPlane.material.color.set(this.sceneColor);                }                else {                    this.backPlane.material.uniforms.color.value.set(this.sceneColor);                }                this.backPlane.material.needsUpdate = true;                break;        }    }    changePhotocallOffset(offset) {        if(!this.backPlane.material.uniforms) {            const shader = this.backPlane.material.userData.shader;            if ( shader ) {                shader.uniforms.offset.value = offset;            }        }        else {            this.backPlane.material.uniforms.offset.value = offset;        }        this.backPlane.material.needsUpdate = true;        this.repeatOffset = offset;    }    // returns value (hex) with the colour in sRGB space    getClothesColour(){        if ( !this.avatarShirt ){ return 0; }           return this.avatarShirt.material.color.getHex(); // css works in sRGB    }    // value (hex colour) in sRGB space     setClothesColour( value ){        if ( !this.avatarShirt ){ return false; }        this.avatarShirt.material.color.set( value );           return true;    }    changeAvatar( avatarName ) {        if ( this.currentCharacter ) this.scene.remove( this.currentCharacter.model ); // delete from scene current model        this.currentCharacter = this.loadedCharacters[avatarName];        this.scene.add( this.currentCharacter.model ); // add model to scene                const diffToGround = this.precomputeFeetOffset(avatarName);        this.loadedCharacters[avatarName].diffToGround = diffToGround;        this.loadedCharacters[avatarName].position = this.currentCharacter.model.position.clone();        const LToePos = this.currentCharacter.skeleton.getBoneByName(this.currentCharacter.LToeName).getWorldPosition(new THREE.Vector3);        const RToePos = this.currentCharacter.skeleton.getBoneByName(this.currentCharacter.RToeName).getWorldPosition(new THREE.Vector3);        const diff = this.currentCharacter.LToePos.y - LToePos.y;                 // this.currentCharacter.model.position.y -= (diffToGround + diff);                  this.bmlApp.onChangeAvatar(avatarName);        this.keyframeApp.onChangeAvatar(avatarName);                if (this.currentCharacter.config) {            this.currentCharacter.skeleton.bones[ this.currentCharacter.config.boneMap["ShouldersUnion"] ].getWorldPosition( this.controls[this.camera].target );            this.controls.forEach((control) => {                control.target.copy(this.controls[this.camera].target);                 control.saveState();                control.update();            });        }        else {            this.changeMode(App.Modes.KEYFRAME);        }        if ( this.gui ){ this.gui.refresh(); }    }    loadAvatar( modelFilePath, configFilePath, modelRotation, avatarName, callback = null, onerror = null ) {        this.loaderGLB.load( modelFilePath, (glb) => {            let model = glb.scene;            model.quaternion.premultiply( modelRotation );            model.castShadow = true;            let skeleton = null;            if(avatarName == "Witch") {                model.traverse( (object) => {                    if ( object.isMesh || object.isSkinnedMesh ) {                        if (object.skeleton){                            skeleton = object.skeleton;                         }                                            if(!object.name.includes("Hat"))                           object.material.side = THREE.FrontSide;                        object.frustumCulled = false;                        object.castShadow = true;                        object.receiveShadow = true;                        if (object.name == "Eyelashes") // eva                        object.castShadow = false;                        if(object.material.map)                         object.material.map.anisotropy = 16;                        if(object.name == "Hair") {                            object.material.map = null;                            object.material.color.set(0x6D1881);                        }                        if(object.name.includes("Bottom")) {                            object.material.map = null;                            object.material.color.set(0x000000);                        }                        if(object.name.includes("Top")) {                            object.material.map = null;                            object.material.color.set(0x000000);                        }                        if(object.name.includes("Shoes")) {                            object.material.map = null;                            object.material.color.set(0x19A7A3);                        }                } else if (object.isBone) {                    object.scale.set(1.0, 1.0, 1.0);                    }                } );            }else{                model.traverse( (object) => {                    if ( object.isMesh || object.isSkinnedMesh ) {                        if (object.skeleton){                            skeleton = object.skeleton;                         }                        object.material.side = THREE.FrontSide;                        object.frustumCulled = false;                        object.castShadow = true;                        object.receiveShadow = true;                        if (object.name == "Eyelashes") // eva                            object.castShadow = false;                        if(object.material.map)                             object.material.map.anisotropy = 16;                } else if (object.isBone) {                    object.scale.set(1.0, 1.0, 1.0);                    }                } );                    this.avatarShirt = model.getObjectByName( "Tops" );            }            if ( avatarName == "Kevin" ){                let hair = model.getObjectByName( "Classic_short" );                if( hair && hair.children.length > 1 ){ hair.children[1].renderOrder = 1; }            }                                    model.name = avatarName;            this.loadedCharacters[avatarName] ={                model, skeleton, config: null            }            if (configFilePath) {                if(typeof(configFilePath) == 'string') {                    fetch( configFilePath ).then(response => response.text()).then( (text) =>{                        let config = JSON.parse( text );                        config._filename = configFilePath;                        this.loadedCharacters[avatarName].config = config;                        this.bmlApp.onLoadAvatar(model, config, skeleton);                        this.keyframeApp.onLoadAvatar(this.loadedCharacters[avatarName]);                        if (callback) {                            callback();                        }                    })                }                else {                    let config = configFilePath;                    this.loadedCharacters[avatarName].config = config;                    this.bmlApp.onLoadAvatar(model, config, skeleton);                    this.keyframeApp.onLoadAvatar(this.loadedCharacters[avatarName]);                                        if (callback) {                        callback();                    }                }            }            else {                this.keyframeApp.onLoadAvatar(this.loadedCharacters[avatarName]);                if (callback) {                    callback();                }            }        }, null, (err) => {            if(onerror) {                onerror(err);            }        });    }    newCameraFrom({azimuthAngle = 0, polarAngle = 0, depth = 0, controlsEnabled = false}) {        let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);        camera.record = true;        let controls = new OrbitControls( camera, this.renderer.domElement );        controls.target.set(0, 1.3, 0);        let newPos = new THREE.Vector3( 0, 1.5, Math.cos(5*Math.PI/180) );        let distance = newPos.distanceTo(controls.target);        let dir = new THREE.Vector3().subVectors(newPos, controls.target).normalize();        dir.applyAxisAngle(new THREE.Vector3(1,0,0), polarAngle * Math.PI / 180);        dir.applyAxisAngle(new THREE.Vector3(0,1,0), azimuthAngle * Math.PI / 180);        newPos.addVectors(controls.target, dir.multiplyScalar(distance));        newPos.add(new THREE.Vector3(0,0,depth));        controls.object.position.set(...newPos);        controls.enableDamping = true; // this requires controls.update() during application update        controls.dampingFactor = 0.1;        controls.enabled = controlsEnabled;        controls.update();        this.cameras.push(camera);         this.controls.push(controls);                return {camera: camera, controls: controls};    }    init() {                this.scene = new THREE.Scene();        const sceneColor = this.sceneColor = window.debugMode ? 0x4f4f9c : 0x46c219;        this.scene.background = new THREE.Color( sceneColor );        // renderer        this.renderer = new THREE.WebGLRenderer( { antialias: true } );        this.renderer.setPixelRatio( window.devicePixelRatio );        this.renderer.setSize( window.innerWidth, window.innerHeight );        this.renderer.toneMapping = THREE.LinearToneMapping;        this.renderer.toneMappingExposure = 1;        this.renderer.shadowMap.enabled = true;        // document.body.appendChild( this.renderer.domElement );                this.newCameraFrom({azimuthAngle: 0, controlsEnabled: true}); // init main Camera (0)        this.newCameraFrom({azimuthAngle: 25});        this.newCameraFrom({azimuthAngle: -25});            this.camera = 0;        // IBL Light        // var that = this;        // new RGBELoader()        //     .setPath( 'data/hdrs/' )        //     .load( 'cafe.hdr', function ( texture ) {        //         texture.mapping = THREE.EquirectangularReflectionMapping;        //         // that.scene.background = texture;        //         that.scene.environment = texture;        //         that.renderer.render( that.scene, that.camera );        // } );        // include lights        let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );        this.scene.add( hemiLight );        let keySpotlight = new THREE.SpotLight( 0xffffff, 3.5, 0, 45 * (Math.PI/180), 0.5, 2 );        keySpotlight.position.set( 0.5, 2, 2 );        keySpotlight.target.position.set( 0, 1, 0 );        // keySpotlight.castShadow = true;        // keySpotlight.shadow.mapSize.width = 1024;        // keySpotlight.shadow.mapSize.height = 1024;        // keySpotlight.shadow.bias = 0.00001;        this.scene.add( keySpotlight.target );        this.scene.add( keySpotlight );        let fillSpotlight = new THREE.SpotLight( 0xffffff, 2.0, 0, 45 * (Math.PI/180), 0.5, 2 );        fillSpotlight.position.set( -0.5, 2, 1.5 );        fillSpotlight.target.position.set( 0, 1, 0 );        // fillSpotlight.castShadow = true;        this.scene.add( fillSpotlight.target );        this.scene.add( fillSpotlight );        let dirLight = this.dirLight = new THREE.DirectionalLight( 0xffffff, 2 );        dirLight.position.set( 1.5, 5, 2 );        dirLight.shadow.mapSize.width = 1024;        dirLight.shadow.mapSize.height = 1024;        dirLight.shadow.camera.left= -1;        dirLight.shadow.camera.right= 1;        dirLight.shadow.camera.bottom= -1;        dirLight.shadow.camera.top= 1;        dirLight.shadow.bias = 0.00001;        dirLight.castShadow = true;        this.scene.add( dirLight );        // add entities        const ground = this.ground = new THREE.Mesh( new THREE.PlaneGeometry(20,20), new THREE.MeshStandardMaterial( { color: sceneColor, opacity: 0.1, transparent:true, depthWrite: true, roughness: 1, metalness: 0 } ) );        ground.name = 'Ground'        ground.rotation.x = -Math.PI / 2;        ground.receiveShadow = true;        this.scene.add( ground );                this.logoTexture = new THREE.TextureLoader().load(this.logo);        this.logoTexture.wrapS = THREE.RepeatWrapping;        this.studioMaterial = new THREE.MeshStandardMaterial( { color: sceneColor, depthWrite: true, roughness: 1, metalness: 0} );        this.repeatOffset = 0;        this.photocallMaterial = new THREE.MeshStandardMaterial( { color: sceneColor, depthWrite: true, roughness: 1, metalness: 0} );        this.photocallMaterial.onBeforeCompile = (shader) => {            shader.uniforms.textureMap = {value: this.logoTexture};             shader.uniforms.repeat = {value: [20,20]};            shader.uniforms.offset = {value: this.repeatOffset};                        shader.vertexShader = '#define USE_UV;\n#define USE_TRANSMISSION;\nvarying vec3 vPosition;\n' + shader.vertexShader;                        //prepend the input to the shader            shader.fragmentShader = '#define USE_UV;\nuniform sampler2D textureMap\n;uniform vec2 repeat; // Texture repetition count\nuniform float offset; // Offset for the texture in UV space;\nvarying vec3 vWorldPosition;\n' + shader.fragmentShader;            shader.fragmentShader =             shader.fragmentShader.replace(            'vec4 diffuseColor = vec4( diffuse, opacity );',             'vec4 diffuseColor = vec4( diffuse, 1.0 );\n\n\            \ if (vWorldPosition.y > 0.0) { \n\                \ // Scale the UV coordinates by the repeat factor\n\                \ vec2 uvScaled = vUv * repeat;\n\n\                \ // Use mod to wrap the UVs for repeating the texture\n\                \ vec2 uvMod = mod(uvScaled, 1.0);\n\                \ // Shrink the UV space to account for the gaps\n\                \ float shrinkFactor = 1.0 - 2.0 * offset; // Shrink the texture to fit between gaps\n\                \ // Only apply the texture inside the non-gap area\n\                \ if (uvMod.x > offset && uvMod.x < (1.0 - offset) && uvMod.y > offset && uvMod.y < (1.0 - offset)) {\n\                    \ // Calculate the "shrunken" UV coordinates to fit the texture within the non-gap area\n\                    \ vec2 uv = fract(uvScaled);\n\                    \ vec2 uvShrink = (uv - vec2(offset)) / shrinkFactor;\n\                    \ vec2 smooth_uv = uvScaled;\n\                    \ vec4 duv = vec4(dFdx(smooth_uv), dFdy(smooth_uv));\n\                    \ vec4 texColor = textureGrad(textureMap, uvShrink, duv.xy, duv.zw);\n\n\                    \ diffuseColor = mix(texColor, diffuseColor, 1.0 - texColor.a);\n\                \ }\n\            \ }\n'            )            this.photocallMaterial.userData.shader = shader;        };        let backPlane = this.backPlane = new THREE.Mesh(createBackdropGeometry(15,10), this.studioMaterial );        backPlane.name = 'Chroma';        backPlane.position.z = -1;        backPlane.receiveShadow = true;        backPlane.castShadow = true;        backPlane.visible=false;        this.scene.add( backPlane );        this.setBackground(this.background);        // so the screen is not black while loading        this.changeCameraMode( false ); //moved here because it needs the backplane to exist        this.renderer.render( this.scene, this.cameras[this.camera] );                this.bmlApp.init(this.scene);        const queryString = window.location.search;        const urlParams = new URLSearchParams(queryString);        let showControls = true;        if(urlParams.has('controls')) {            showControls = !(urlParams.get('controls') === "false");        }        let modelToLoad = ['https://webglstudio.org/3Dcharacters/Eva_Low/Eva_Low.glb', 'https://webglstudio.org/3Dcharacters/Eva_Low/Eva_Low.json', (new THREE.Quaternion()).setFromAxisAngle( new THREE.Vector3(1,0,0), 0 ), "EvaLow" ];        if(urlParams.has('avatar')) {            let avatar = urlParams.get('avatar');            const path = avatar.split(".");            let filename = path[path.length-2];            filename = filename.split("/");            filename = filename.pop();                        avatar += avatar.includes('models.readyplayer.me') ? '?pose=T&morphTargets=ARKit&lod=1' : '';            modelToLoad = [ avatar, urlParams.get('config'), new THREE.Quaternion(), filename];                  }        this.loadAvatar(modelToLoad[0], modelToLoad[1], modelToLoad[2], modelToLoad[3], () => {            this.changeAvatar( modelToLoad[3] );            if ( typeof AppGUI != "undefined" && showControls) {                 this.gui = new AppGUI( this );                 if(!this.gui.avatarOptions[modelToLoad[3]]) {                    const name = modelToLoad[3];                    modelToLoad[3] = modelToLoad[0].includes('models.readyplayer.me') ? ("https://models.readyplayer.me/" + name + ".png?background=68,68,68") : AppGUI.THUMBNAIL;                    this.gui.avatarOptions[name] = modelToLoad;                    this.gui.refresh();                }            }            else {                window.document.body.appendChild(this.renderer.domElement);            }            this.animate();            $('#loading').fadeOut(); //hide();            this.isAppReady = true;                                    if(this.pendingMessageReceived) {                this.onMessage( this.pendingMessageReceived );                this.pendingMessageReceived = null; // although onMessage is async, the variable this.pendingMessageReceived is not used. So it is safe to delete            }        });        this.animationRecorder = new AnimationRecorder(this.cameras.length, this);        this.animationRecorder.onStartCapture = (v) => {            if(this.gui) {                this.gui.showCaptureModal(v);            }        };        this.animationRecorder.onStopCapture = () => {            if(this.gui) {                this.gui.hideCaptureModal();            }        };        window.addEventListener( "message", this.onMessage.bind(this) );        window.addEventListener( 'resize', this.onWindowResize.bind(this) );    }    animate() {        requestAnimationFrame( this.animate.bind(this) );        // don't let the camera to be under the ground         if(this.cameraMode) {            let centerPosition = this.controls[this.camera].target.clone();            centerPosition.y = 0;            let groundPosition = this.cameras[this.camera].position.clone();            groundPosition.y = 0;            let d = (centerPosition.distanceTo(groundPosition));                let origin = new THREE.Vector2(this.controls[this.camera].target.y,0);            let remote = new THREE.Vector2(0,d); // replace 0 with raycasted ground altitude            let angleRadians = Math.atan2(remote.y - origin.y, remote.x - origin.x);            this.controls[this.camera].maxPolarAngle = angleRadians - 0.01;        }        this.controls[this.camera].update(); // needed because of this.controls.enableDamping = true        let delta = this.clock.getDelta()                 // delta *= this.speed;        this.elapsedTime += delta;                switch( this.mode ){            case App.Modes.SCRIPT:                 this.bmlApp.update(delta);                 break;            case App.Modes.KEYFRAME:                this.keyframeApp.update(delta);                 break;            default:                break;        }                if (this.animationRecorder && this.animationRecorder.isRecording) {            this.animationRecorder.update(this.scene, this.cameras);        }                this.renderer.render( this.scene, this.cameras[this.camera] );    }    precomputeFeetOffset(avatarName) {        const character = this.loadedCharacters[avatarName];        const map = computeAutoBoneMap( character.skeleton );        character.LToeName = character.model.getObjectByName(map.nameMap.LFoot).children[0].name;        character.RToeName = character.model.getObjectByName(map.nameMap.RFoot).children[0].name;        const LtoePos = character.model.getObjectByName(map.nameMap.LFoot).children[0].getWorldPosition(new THREE.Vector3());        const RtoePos = character.model.getObjectByName(map.nameMap.RFoot).children[0].getWorldPosition(new THREE.Vector3);              // Cast a ray downwards from the left toe's position              let dir = new THREE.Vector3(0, 1, 0);        this.raycaster.layers.enableAll()        this.raycaster.set( new THREE.Vector3(LtoePos.x, -1, LtoePos.z), dir);                      // const obj = character.model.children[0].getObjectByName("Wolf3D_Outfit_Footwear");        // obj.material.side = THREE.DoubleSide;        const intersects = this.raycaster.intersectObjects(character.model.children[0].children, true); // Adjust based on your scene setup        let diff = 0;        if (intersects.length > 0) {            // Get the ground position from the first intersection            const groundPosition = intersects[0].point;            diff = groundPosition.y;        }        character.LToePos = LtoePos;        character.RToePos = RtoePos;        return diff;    }    onMessage(event) {        if ( !this.isAppReady ) {             this.pendingMessageReceived = event;             return;         }        let data = event.data;                if ( typeof( data ) == "string" ) {             try {                 data =  JSON.parse( data );             }            catch( e ) {                 if(data.includes("setImmediate")) {                    return;                }                console.error("Error while parsing an external message: ", event );             };        }                if ( !data ) {            return;        }        if ( Array.isArray(data) ){            this.changeMode(App.Modes.SCRIPT);            this.bmlApp.onMessage(data, (processedData) => {                if(this.gui) {                    this.gui.setBMLInputText(                         JSON.stringify(this.bmlApp.msg.data, function(key, val) {                            return val.toFixed ? Number(val.toFixed(3)) : val;                        })                     );                }            });             return;        }                                 if(data.type == 'bvh' || data.type == 'bvhe') {            this.changeMode(App.Modes.KEYFRAME);            this.keyframeApp.onMessage(data, () => {                if(this.gui) {                    this.gui.refresh();                }            });        }        else {            return;         }    }        onWindowResize() {        for (let i = 0; i < this.cameras.length; i++) {            this.cameras[i].aspect = window.innerWidth / window.innerHeight;            this.cameras[i].updateProjectionMatrix();        }        this.renderer.setSize( window.innerWidth, window.innerHeight );    }    toggleCameraMode() {         this.changeCameraMode( !this.cameraMode );     }    changeCameraMode( mode ) {        if ( mode ) {            this.controls[this.camera].enablePan = true;            this.controls[this.camera].minDistance = 0.1;            this.controls[this.camera].maxDistance = 10;            this.controls[this.camera].minAzimuthAngle = THREE.Infinity;            this.controls[this.camera].maxAzimuthAngle = THREE.Infinity;            this.controls[this.camera].minPolarAngle = 0.0;            this.controls[this.camera].maxPolarAngle = Math.PI;             } else {            this.controls[this.camera].enablePan = false;            this.controls[this.camera].minDistance = 0.7;            this.controls[this.camera].maxDistance = 2;            this.controls[this.camera].minAzimuthAngle = -2;            this.controls[this.camera].maxAzimuthAngle = 2;            this.controls[this.camera].minPolarAngle = 0.6;            this.controls[this.camera].maxPolarAngle = 2.1;            if ( this.currentCharacter && this.currentCharacter.config ){                this.currentCharacter.skeleton.bones[ this.currentCharacter.config.boneMap["ShouldersUnion"] ].getWorldPosition( this.controls[this.camera].target );            }        }        this.controls[this.camera].update();        this.cameraMode = mode;     }    loadFiles( files, callback ) {        for(let i = 0; i < files.length; i++) {            //load json (bml) file            const file = files[i];            const extension = file.name.substr(file.name.lastIndexOf(".") + 1);            const formats = ['bvh', 'bvhe', 'glb', 'gltf'];            if(formats.indexOf(extension) < 0) {                alert(file.name +": Format not supported.\n\nFormats accepted:\n\t'bvh', 'bvhe'\n\t");            }        }                this.keyframeApp.processMessageFiles(files).then((data) => {            if(data[0].length) {                this.changeMode(App.Modes.KEYFRAME);                this.keyframeApp.onChangeAnimation(data[0]);            }            if(callback) {                callback(data[0]);            }        });    }    openAtelier(name, model, config, fromFile = true, rotation = 0) {                    let rawConfig = config;        if(config && !fromFile) {            rawConfig = JSON.parse(JSON.stringify(config));            const skeleton = this.currentCharacter.skeleton;            const innerLocationToObjects = (locations) => {                let result = {};                const bindMat4 = new THREE.Matrix4();                const bindMat3 = new THREE.Matrix3();                for(let part in locations) {                                        const obj = [];                    const location = locations[part];                    let idx = findIndexOfBoneByName( skeleton, location.parent.name );                    if ( idx < 0 ){ continue; }                        obj.push(location.parent.name);                    bindMat4.copy( skeleton.boneInverses[ idx ] ).invert();                    obj.push( location.position.clone().applyMatrix4( bindMat4 ) ); // from mesh space to bone local space                                        // check direction of distance vector                     if(location.direction) {                        bindMat3.setFromMatrix4( bindMat4 );                        obj.push( location.direction.clone().applyMatrix3( bindMat3 ) );                    }                        result[part] = obj;                }                return result;            }            rawConfig.bodyController.bodyLocations = innerLocationToObjects(config.bodyController.bodyLocations);            rawConfig.bodyController.handLocationsL = innerLocationToObjects(config.bodyController.handLocationsL);            rawConfig.bodyController.handLocationsR = innerLocationToObjects(config.bodyController.handLocationsR);        }        const atelierData = [name, model, rawConfig, rotation];                localStorage.setItem("atelierData", JSON.stringify(atelierData));        if(!this._atelier || this._atelier.closed) {            this._atelier = window.open(App.ATELIER_URL, "Atelier");                    }        else {            this._atelier.location.reload();        }        this._atelier.focus();    }}// Function to create a curved backdrop geometryfunction createBackdropGeometry(width = 5, height = 5, segments = 32) {    // Create a geometry object    const geometry = new THREE.PlaneGeometry(width, height, segments, segments);    const position = geometry.attributes.position;    // Modify vertices to create a curved transition from floor to background    let vertices = [];    for (let i = 0; i < position.count; i++) {        let vertex = new THREE.Vector3();        vertex.fromBufferAttribute( position, i );               if( vertex.y < 0) {            vertex.z = -vertex.y; // Apply curve on Z axis            vertex.y = 0;        }        vertices.push(vertex.x);        vertices.push(vertex.y);        vertices.push(vertex.z);    }    vertices = new Float32Array(vertices);    geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );    return geometry;}let app = new App();app.init();window.global = {app:app};
export { BMLApp, KeyframeApp, AnimationRecorder, App} 
